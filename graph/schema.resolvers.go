package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"
	"weather-api/graph/model"
)

const (
	weatherApiUrl = "https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline"
	unit          = "metric"
)

// GetWeatherData is the resolver for the getWeatherData field.
func (r *queryResolver) GetWeatherData(ctx context.Context, city string, date *string) (*model.WeatherResponse, error) {
	apiKey := os.Getenv("WEATHER_API_KEY")

	givenDate := time.Now().Format("2006-01-02")
	if date != nil {
		givenDate = *date
	}

	url := fmt.Sprintf("%s/%s/%s?unitGroup=%s&key=%s", weatherApiUrl, city, givenDate, unit, apiKey)
	resp, err := http.Get(url)

	if err != nil {
		return nil, fmt.Errorf("failed to send the request: %w", err)
	}

	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("received non-200 response: %d", resp.StatusCode)
	}

	body, errRead := io.ReadAll(resp.Body)

	if errRead != nil {
		return nil, fmt.Errorf("error in reading the response: %w", errRead)
	}

	var weather model.WeatherResponse
	if errMarshal := json.Unmarshal(body, &weather); err != nil {
		return nil, fmt.Errorf("error unmarshalling response: %w", errMarshal)
	}
	return &weather, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
